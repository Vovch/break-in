<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Break In</title>
</head>
<body>
<main id="play-area"></main>

<script>
    const mediator = {
        subscribers: {},
        subscribe(name, subscription) {
            this.subscribers[name] = this.subscribers[name]
                ? [...this.subscribers[name], subscription]
                : [subscription];
        },
        unsubscribe(name, subscription) {
            if (this.subscribers[name]) {
                this.subscribers[name] = this.subscribers[name].filter(sub => sub !== subscription);
            }
        },
        publish(name, data) {
            this.subscribers[name]?.forEach((sub) => sub(data))
        },
    }
    const events = {
        RESIZE: 'RESIZE',
        LOSE_BALL: 'LOSE_BALL',
    }

    const intersectionTypes = {
        VERTICAL: 'VERTICAL',
        HORIZONTAL: 'HORIZONTAL',
        PLAYER: 'PLAYER',
        NONE: 'NONE',
    }
    const playArea = document.getElementById('play-area');
    let mouseX, mouseY;
    let prevTime, currTime;
    let isGameStarted = false;

    window.addEventListener('resize', () => mediator.publish(events.RESIZE));
    document.addEventListener('click', () => isGameStarted = true)
    document.addEventListener('mousemove', (event) => {
        mouseX = event.clientX;
        mouseY = event.clientY;
    });

    // line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
    // Determine the intersection point of two line segments
    // Return FALSE if the lines don't intersect
    const findLineSegmentsIntersection = ({x1, y1, x2, y2}, {x1: x3, y1: y3, x2: x4, y2: y4}) => {

        // Check if none of the lines are of length 0
        if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
            return false
        }

        const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))

        // Lines are parallel
        if (denominator === 0) {
            return false
        }

        let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
        let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator

        // is the intersection along the segments
        if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
            return false
        }

        // Return an object with the x and y coordinates of the intersection
        let x = x1 + ua * (x2 - x1)
        let y = y1 + ua * (y2 - y1)

        return {x, y}
    }

    const findDistance = ({x, y}, {x: x2, y: y2}) => Math.sqrt((x - x2) ** 2 + (y - y2) ** 2);

    class Player {
        x;
        y;
        playerElement;
        playerRect;

        constructor() {
            const playerWidth = 10;
            const playerHeight = 3
            const player = document.createElement('div');
            player.style = `width: ${playerWidth}vw; height: ${playerHeight}vh; background: black; position: fixed; bottom: 1vh; left: 50vw; transform: translate(-50%, -50%)`;

            playArea.appendChild(player);

            this.playerElement = player;
            this.move();
        }

        getCollisionLines() {
            const top = {
                x1: this.playerRect.x,
                y1: this.playerRect.y,
                x2: this.playerRect.x + this.playerRect.width,
                y2: this.playerRect.y,
            }

            return [
                {line: top, type: intersectionTypes.PLAYER},
            ];
        }

        move() {
            this.playerRect = this.playerElement.getBoundingClientRect();
            let playerX;

            if (mouseX < this.playerRect.width / 2) {
                playerX = this.playerRect.width / 2;
            } else if (mouseX > innerWidth - this.playerRect.width / 2) {
                playerX = innerWidth - this.playerRect.width / 2;
            } else {
                playerX = mouseX;
            }

            this.playerElement.style.left = `${playerX}px`;
        }
    }

    class Ball {
        x;
        y;
        speed = 5;
        xSpeed = Math.cos(2 * Math.PI / 6) * this.speed;
        ySpeed = -Math.sin(2 * Math.PI / 6) * this.speed;
        ballElement;
        ballDiameter = 1;
        totalDistanceAvailable = 0;
        ballTrajectory = [];

        constructor() {
            const ball = document.createElement('div');
            ball.style = `width: ${this.ballDiameter}vh; height: ${this.ballDiameter}vh; background: black; position: fixed; bottom: 7vh; left: 50vw; transform: translate(-50%, -50%); border-radius: 50%;`

            playArea.appendChild(ball);
            const ballRect = ball.getBoundingClientRect();
            this.x = ballRect.x;
            this.y = ballRect.y;
            ball.style.top = `${this.y}px`;
            ball.style.removeProperty('bottom');

            this.ballElement = ball;

            mediator.subscribe(events.LOSE_BALL, () => {
                this.speed = 5;
                this.xSpeed = Math.cos(2 * Math.PI / 6) * this.speed;
                this.ySpeed = Math.sin(2 * Math.PI / 6) * this.speed;
            })
        }

        calcCollisions(player, level) {
            const availablePathPercent = (this.totalDistanceAvailable - this.distanceTravelled) / this.totalDistanceAvailable;
            const prevPoint = this.ballTrajectory.slice(-1)[0];

            const ballMovementLine = {
                x1: prevPoint.x,
                y1: prevPoint.y,
                x2: prevPoint.x + this.xSpeed * availablePathPercent,
                y2: prevPoint.y + this.ySpeed * availablePathPercent,
            };

            const intersections = [...level.getCollisionLines(), ...player.getCollisionLines()]
                .map((intersection) => ({
                    ...intersection,
                    intersection: findLineSegmentsIntersection(ballMovementLine, intersection.line)
                }))
                .filter(({intersection}) =>
                    intersection && (
                        Math.round(intersection.x * 1000) !== Math.round(prevPoint.x * 1000) ||
                        Math.round(intersection.y * 1000) !== Math.round(prevPoint.y * 1000)
                    )
                )

            let closestIntersection;

            if (intersections.length) {
                closestIntersection = intersections.reduce((acc, item) =>
                    findDistance(prevPoint, acc.intersection) > findDistance(prevPoint, item.intersection) ? item : acc
                );
            }

            closestIntersection?.onCollision?.();

            if (closestIntersection?.type === intersectionTypes.HORIZONTAL) {
                this.xSpeed = -this.xSpeed;
            } else if (closestIntersection?.type === intersectionTypes.VERTICAL) {
                this.ySpeed = -this.ySpeed;
            } else if (closestIntersection?.type === intersectionTypes.PLAYER) {
                this.speed += 0.2;
                this.ySpeed = -this.ySpeed;

                const interactionPosition = player.playerRect.x + player.playerRect.width / 2 - closestIntersection.intersection.x;
                const coefficient = -(interactionPosition / player.playerRect.width);
                const final = Math.PI * coefficient * 0.8;

                this.xSpeed = Math.sin(final) * this.speed;
                this.ySpeed = -Math.abs(Math.cos(final) * this.speed);
            }

            let nextX = closestIntersection ? closestIntersection.intersection.x : ballMovementLine.x2;
            let nextY = closestIntersection ? closestIntersection.intersection.y : ballMovementLine.y2;

            this.ballTrajectory.push({x: nextX, y: nextY});

            this.x = nextX;
            this.y = nextY;

            this.distanceTravelled += findDistance({x: nextX, y: nextY}, {x: prevPoint.x, y: prevPoint.y});

            if (!(this.totalDistanceAvailable.toFixed(2) <= this.distanceTravelled.toFixed(2))) {
                this.calcCollisions(player, level);
            }
        }

        move(player, level) {
            this.ballTrajectory = [{x: this.x, y: this.y}];
            this.distanceTravelled = 0;
            this.totalDistanceAvailable = findDistance({x: this.x, y: this.y}, {
                x: this.x + this.xSpeed,
                y: this.y + this.ySpeed
            });

            if (!isGameStarted) {
                this.x = player.playerRect.left + player.playerRect.width / 2;
                this.y = player.playerRect.top - 10;
            } else {
                this.calcCollisions(player, level);
            }

            this.ballElement.style.left = `${this.x}px`;
            this.ballElement.style.top = `${this.y}px`;
        }
    }

    class Brick {
        x;
        y;
        width;
        height;
        brickElement;
        initialHealth;
        health;
        onDestroy;

        constructor(x, y, health = 10, onDestroy) {
            const brick = document.createElement('div');
            brick.style = `background: black; position: absolute; left: ${x}; top: ${y}; width: 4vw; height: 4vh;`;
            playArea.appendChild(brick);

            this.brickElement = brick;
            this.initialHealth = health;
            this.health = health;
            this.onDestroy = onDestroy

            this.onCollision = this.onCollision.bind(this);
            this.calculatePosition = this.calculatePosition.bind(this);
            mediator.subscribe(events.RESIZE, this.calculatePosition);

            this.calculatePosition();
        }

        calculatePosition() {
            const {x, y, width, height} = this.brickElement.getBoundingClientRect();

            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        onCollision() {
            this.health--;
            this.brickElement.style.opacity = String(this.health / this.initialHealth);

            if (this.health < 1) {
                mediator.unsubscribe(events.RESIZE, this.calculatePosition)
                this.onDestroy?.(this);
            }
        }

        getCollisionLines() {
            const left = {x1: this.x, y1: this.y, x2: this.x, y2: this.y + this.height};
            const right = {x1: this.x + this.width, y1: this.y, x2: this.x + this.width, y2: this.y + this.height};
            const top = {x1: this.x, y1: this.y, x2: this.x + this.width, y2: this.y};
            const bottom = {x1: this.x, y1: this.y + this.height, x2: this.x + this.width, y2: this.y + this.height};

            return [
                {line: left, type: intersectionTypes.HORIZONTAL, onCollision: this.onCollision},
                {line: right, type: intersectionTypes.HORIZONTAL, onCollision: this.onCollision},
                {line: top, type: intersectionTypes.VERTICAL, onCollision: this.onCollision},
                {line: bottom, type: intersectionTypes.VERTICAL, onCollision: this.onCollision},
            ];
        }
    }

    class BaseLevel {
        bricks = [];

        constructor() {
            this.handleBrickDestroy = this.handleBrickDestroy.bind(this);
        }

        getCollisionLines() {
            const left = {x1: 1, y1: -1, x2: 1, y2: innerHeight};
            const right = {x1: innerWidth, y1: -1, x2: innerWidth, y2: innerHeight};
            const top = {x1: -1, y1: 1, x2: innerWidth, y2: 1};
            const bottom = {x1: -1, y1: innerHeight, x2: innerWidth, y2: innerHeight};

            return [
                {line: left, type: intersectionTypes.HORIZONTAL},
                {line: right, type: intersectionTypes.HORIZONTAL},
                {line: top, type: intersectionTypes.VERTICAL},
                {line: bottom, type: intersectionTypes.VERTICAL, onCollision: this.handleLose},
            ];
        }

        handleLose() {
            isGameStarted = false;
            mediator.publish(events.LOSE_BALL);
        }

        handleBrickDestroy(destroyed) {
            this.bricks = this.bricks.filter(brick => brick !== destroyed);
        }
    }

    class Level1 extends BaseLevel {
        constructor() {
            super();

            for (let i = 1; i <= 14; i++) {
                for (let j = 1; j <= 19; j++) {
                    this.bricks.push(new Brick(`${j * 5 - 2}vw`, `${i * 5}vh`, 3, this.handleBrickDestroy));
                }
            }
        }

        getCollisionLines() {
            return [...super.getCollisionLines(), ...this.bricks.flatMap(brick => brick.getCollisionLines())];
        }
    }

    const gameLoop = (player, ball, level) => {
        currTime = Date.now();

        player.move(player);
        ball.move(player, level);

        requestAnimationFrame(() => gameLoop(player, ball, level));

        prevTime = Date.now();
    }

    gameLoop(new Player(), new Ball(), new Level1());
</script>
</body>
</html>